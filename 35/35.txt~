 寻找宝藏
序号：#37 难度：困难  时间限制：1000ms  内存限制：10M
描述

很久以前，有一个很古老而且很富有的民族，但是有一天，他们惨遭外敌入侵，族人都惨遭杀害无一幸免。族长在最后时刻，为了防止财宝落入贼人之手，把财宝藏在了一个秘密的地方，并设置了一些机关，必须解开所有机关才能够获得宝藏。
假设族长一共设置 n 道机关，分别用0 ~ n-1表示。这些机关中有的可以直接解开，有的机关必须要先解开另一个或另一些机关之后才能解开该机关。
有一天你机缘巧合来到了这个地方，请问你能否顺利解开所有机关拿到宝藏？

举例：
假设有两个机关：0 和 1。
如果要求解开1之前先解开 0，而对 0 没有先决条件要求，则可以先解开 0，再解开 1，从而获得宝藏；
如果要求解开1之前先解开 0，同时解开 0 之前先解开 1，则由于 0 与 1 互为先决条件，所以无法解开 0 与 1，因此无法获得宝藏。
输入

使用 (;) 隔开的 k 组数据。(k >= 1，不固定)
第 1 组数据是一个正整数 n，表示一共设置了多少机关。
第 2~k 组数据由使用 (,) 分隔的两个整数构成，分别为 a 和 b，表示要解开 a 机关必须先解开 b 机关，a 与 b 的范围：0 <= a,b <= n-1
输出

输出字符串类型的 "true" 或者 "false"，均为小写，表示是否能够解开所有机关拿到宝藏。
输入样例

2;0,1

2;0,1;1,0

12;0,1;1,2;2,3;3,4;4,5;5,6;6,7;7,8;8,9;9,10;10,11;7,1

95;25,30;91,4;48,12;32,66;61,48;52,25;56,91;65,85;8,74;38,79;51,39;57,7;49,17;76,23;2,71;87,26;6,84;30,53;2,61;25,62;15,76;86,71;73,57;61,81;36,5;65,87;44,28;93,92;45,75;21,46;51,14;71,56;4,6;15,5;67,39;66,81;21,57;57,93;20,24;80,56;29,51;48,72;78,47;69,29;27,90;74,77;9,50;38,12;56,52;17,28;90,82;15,17;45,72;15,64;2,1;25,30;51,73;7,35;25,76;63,51;71,42;33,80;92,71;92,53

输出样例

true

false

false

true
